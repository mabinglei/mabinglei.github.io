[{"title":"将Java jar包注册为Linux服务","url":"/Java-jar-config-Linux-service.html","content":"创建目录cd /homemkdir HttpGetTimecd HttpGetTime\n\n编写启动脚本vim start.sh#!/bin/shnohup /usr/bin/java -jar  /root/HttpGetTime.jar &gt;  /home/HttpGetTime/HttpGetTime.log &amp;echo $! &gt; /var/run/HttpGetTime.pid\n\n编写停止脚本vim stop.sh#!/bin/bashPID=$(cat /var/run/HttpGetTime.pid)kill -9 $PID\n\n编写服务cd /usr/lib/systemd/systemvim HttpGetTime.service[Unit]Description=HttpGetTime_serviceAfter=syslog.target network.target[Service]Type=forkingExecStart=/home/HttpGetTime/start.shExecStop=/home/HttpGetTime/stop.shPrivateTmp=true[Install]WantedBy=multi-user.target\n\n服务启动、停止、开机自启systemctl [start|stop|enable] HttpGetTime.service\n","categories":["Linux"],"tags":["Linux","Java"]},{"title":"Nginx sni proxy, get real IP and build","url":"/Nginx-sni-proxy-get-real-IP-build.html","content":"一、编译Nginx\n获取Nginx源码\n解压并安装\n安装gcc等编译工具\n编译安装并添加下面的模块\nstream \nstream_ssl_preread_module \nstream_ssl_module \nhttp_ssl_module \nhttp_realip_module \nstream_realip_module\n\n\n\n./configure --prefix=/usr/local/nginx --sbin-path=/usr/local/sbin/nginx --conf-path=/usr/local/nginx/nginx.conf --with-stream --with-stream_ssl_preread_module --with-stream_ssl_module --with-http_ssl_module --with-http_realip_module --with-stream_realip_modulemakemake install\n\n二、修改配置文件#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;# 流量转发核心配置stream &#123;    # 这里就是 SNI 识别，将域名映射成一个配置名    map $ssl_preread_server_name $backend_name &#123;        xxx.com web;        api.xxx.com api;        gateway.xxx.com tls;    # 域名都不匹配情况下的默认值        default web;    &#125;    # web    upstream web &#123;        server 127.0.0.1:8445;    &#125;    # api    upstream api &#123;        server 127.0.0.1:8444;    &#125;    # tls    upstream tls &#123;        server 127.0.0.1:8443;    &#125;    # 监听 443 并开启 ssl_preread  \t# server 443 开启 proxy_protocol 后，分流后的所有服务也必须开启 proxy_protocol，否则会报错    server &#123;        listen 443 reuseport;        proxy_pass $backend_name;        ssl_preread on;        proxy_protocol on;    &#125;\t\t# 对于不支持 proxy_protocol 的服务，需要关闭 proxy_protocol    server &#123;        listen 8443 proxy_protocol so_keepalive=on;        proxy_protocol off; #把 proxy_protocol 关掉，因为不支持！这是关键        proxy_connect_timeout 300s;        proxy_timeout 300s;        proxy_pass 127.0.0.1:8446; #forward to tls server    &#125;&#125;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    log_format httplog &#x27;$remote_addr|$http_x_real_ip|$http_x_forwarded_for|$proxy_protocol_addr&#x27;;    #access_log  logs/access.log  main;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen 80 proxy_protocol;        server_name  xxx.com;    # 强制跳转 https        location / &#123;            return 301 https://$host$request_uri;        &#125;        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;    server &#123;        listen 127.0.0.1:8445 ssl proxy_protocol; # 这里需要开启 proxy_protocol        server_name  xxx.com;        ssl_certificate      /etc/nginx/xxx.com_cert.pem;        ssl_certificate_key  /etc/nginx/xxx.com_key.pem;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_ciphers  HIGH:!aNULL:!MD5;        ssl_prefer_server_ciphers  on;        location / &#123;            root /usr/share/nginx/html/;            index index.html;            error_page 404 /404.html;            # 用于去除 URL 末尾的html扩展名，访问不存在的页面则跳转404页面            if ($request_uri ~ ^/index(\\?|$)) &#123;                return 302 https://$host;            &#125;            if ($request_uri ~ ^/index\\.html(\\?|$)) &#123;                return 302 https://$host;            &#125;            if ($request_uri ~ ^/(.*)\\.html(\\?|$)) &#123;                return 302 https://$host/$1;            &#125;            try_files $uri $uri.html $uri/ =404;        &#125;    &#125;    server &#123;        listen 127.0.0.1:8444 ssl proxy_protocol; # 这里需要开启 proxy_protocol        set_real_ip_from 127.0.0.1;        real_ip_recursive on;        real_ip_header proxy_protocol;        server_name  api.xxx.com;        ssl_certificate      /etc/nginx/xxx.com_cert.pem;        ssl_certificate_key  /etc/nginx/xxx.com_key.pem;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_ciphers  HIGH:!aNULL:!MD5;        ssl_prefer_server_ciphers  on;        location / &#123;            proxy_pass http://127.0.0.1:8001;            proxy_set_header X-Real-IP $remote_addr; #把处理后的$remote_addr赋值给http请求头X-Real-IP, 便于下一级服务获取真实ip            proxy_set_header X-Forwarded-For $remote_addr;            proxy_set_header Host $host;        &#125;    &#125;  &#125;\n\n三、后台服务器获取IP地址\n添加依赖到 pom.xml 中\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;    &lt;version&gt;4.5.7&lt;/version&gt;&lt;/dependency&gt;\n\n获取IP地址\n@GetMapping(&quot;/ipCheck&quot;)    public ResponseEntity&lt;IPCheckResponse&lt;String&gt;&gt; forwardRequest(HttpServletRequest request) &#123;        // 获取客户端IP地址        String ip = request.getHeader(&quot;X-Real-IP&quot;);        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            // 获取代理IP地址            ip = request.getHeader(&quot;x-forwarded-for&quot;);        &#125;\t\t\t\treturn ResponseEntity.ok(new IPCheckResponse&lt;&gt;(&quot;200&quot;, &quot;Check Success&quot;, ip));&#125;\n\n测试\ncurl https://xxx.com/ipCheck\n\n返回数据\n&#123;    &quot;code&quot;: &quot;200&quot;,    &quot;message&quot;: &quot;Check Success&quot;,    &quot;data&quot;: &quot;&#123;\\n  \\&quot;ip\\&quot;: \\&quot;100.100.100.100\\&quot;,\\n  \\&quot;hostname\\&quot;: \\&quot;host-by.xxx.com\\&quot;,\\n  \\&quot;city\\&quot;: \\&quot;Los Angeles\\&quot;,\\n  \\&quot;region\\&quot;: \\&quot;California\\&quot;,\\n  \\&quot;country\\&quot;: \\&quot;US\\&quot;,\\n  \\&quot;loc\\&quot;: \\&quot;38.0559,-128.2666\\&quot;,\\n  \\&quot;org\\&quot;: \\&quot;AS888 XXX Cloud Services\\&quot;,\\n  \\&quot;postal\\&quot;: \\&quot;00000\\&quot;,\\n  \\&quot;timezone\\&quot;: \\&quot;America/Los_Angeles\\&quot;\\n&#125;&quot;&#125;\n\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"OpenWrt官方固件设置","url":"/OpenWrt-official-firmware-setup.html","content":"一、扩容官方固件默认空间分配较少，不足以安装常用插件，官方提供了一键扩容脚本\n\n安装必备软件包\nopkg updateopkg install parted losetup resize2fs blkid\n\n下载脚本并赋予执行权限\nwget -U &quot;&quot; -O expand-root.sh &quot;https://openwrt.org/_export/code/docs/guide-user/advanced/expand_root?codeblock=0&quot;chmod +x expand-root.sh\n\n执行脚本并重启系统\n./expand-root.shreboot #系统会重启两次\n\n二、修改启动等待时间官方固件默认启动等待时间是5秒，这里把它修改成0秒\n   vim /boot/grub/grub.cfg#把set timeout=&quot;5&quot;改成set timeout=&quot;0&quot;，然后保存\n\n三、设置samba局域网共享\n安装必需组件\n\nsamba相关组件应该在Luci界面安装，这里只安装shadow-useradd\n\nopkg updateopkg install shadow-useradd\n\n挂载磁盘\nmount | grep sdb\n\n创建系统用户（无 shell）\nuseradd -M -s /bin/false nasgrep nas /etc/passwd #验证\n\n创建 Samba 用户\nsmbpasswd -a naspdbedit -L #验证\n\n设置目录权限 \next4（最稳）\nchown -R nas:nas /mnt/sdb1chmod -R 0755 /mnt/sdb1\n\nFAT &#x2F; NTFS &#x2F; exFAT（权限由挂载决定）\nchmod -R 0777 /mnt/sdb1\n\nSamba 配置文件 \nvim /etc/config/samba4\n\n按照下面的配置\nconfig samba        option workgroup &#x27;WORKGROUP&#x27;        option charset &#x27;UTF-8&#x27;        option description &#x27;Samba on OpenWRT&#x27;        option macos &#x27;1&#x27;config sambashare        option name &#x27;NAS&#x27;        option path &#x27;/mnt/sdb1&#x27;        option read_only &#x27;no&#x27;        option users &#x27;nas&#x27;        option guest_ok &#x27;yes&#x27;        option create_mask &#x27;0666&#x27;        option dir_mask &#x27;0777&#x27;\n\n启动服务\n/etc/init.d/samba4 enable/etc/init.d/samba4 restart\n\n客户端访问smb://192.168.1.1 ，用户名：nas ，密码根据自己设置的填写\n\n\n","categories":["Linux"],"tags":["Linux","OpenWrt"]},{"title":"基于嵌入式Qt的多功能电子台历","url":"/Qt-clock-embedded.html","content":"1．嵌入式系统概念简述嵌入式系统是指将计算机系统集成到其它产品中的技术。这种技术的目的是使用计算机系统来控制和协调其它产品的运行，并通过计算机系统来实现更复杂和更高效的功能。  \n嵌入式系统通常由以下几个部分组成：  \n\n微处理器：这是嵌入式系统的核心，用于执行指令并控制其它部件的运行。  \n存储器：包括ROM、RAM和Flash等不同类型的存储器，用于保存程序和数据。  \n接口：包括串口、并口、SPI、I2C等不同类型的接口，用于连接外部设备和传输数据。  \n外设：包括显示器、键盘、鼠标、打印机、传感器等不同类型的外设，用于实现更多的功能和交互。\n\n嵌入式系统应用广泛，可以用于汽车、家电、医疗、军事等不同领域。 \n2．环境搭建\n安装虚拟机  首先，需要在电脑上安装好Parallels Desktop软件。  打开Parallels Desktop软件，在软件的主界面中点击“创建新虚拟机”按钮。  在弹出的向导窗口中，选择“安装操作系统”，并点击“继续”按钮。  接下来，选择“Ubuntu”作为要安装的操作系统，并点击“继续”按钮。  在接下来的界面中，输入虚拟机的名称、用户名和密码，并设置虚拟机的内存、硬盘大小等参数。  点击“完成”按钮，开始安装Ubuntu虚拟机。  安装过程中，会提示选择安装方式，选择“安装Ubuntu”即可。  安装完成后，在Parallels Desktop的主界面中，会看到刚才创建的Ubuntu虚拟机，双击虚拟机图标即可启动虚拟机。\n\n\n在虚拟机中，输入用户名和密码，登录Ubuntu系统，即可使用Ubuntu虚拟机。  \n\n\n安装Linux系统并进行NFS及交叉编译工具链等的配置   设置NFS共享目录：  在Ubuntu系统上安装NFS服务器软件包：  sudo apt-get install nfs-kernel-server  创建共享目录&#x2F;nfs-share，并设置相应的权限：  sudo mkdir &#x2F;nfs-share  sudo chmod -R 777 &#x2F;nfs-share  编辑&#x2F;etc&#x2F;exports文件，添加对&#x2F;nfs-share目录的共享配置：  sudo nano &#x2F;etc&#x2F;exports  在&#x2F;etc&#x2F;exports文件中添加如下内容：  &#x2F;nfs-share *(rw,sync,no_subtree_check)  重启NFS服务器，使配置生效：  sudo service nfs-kernel-server restart  在开发板上挂载共享目录：  sudo mount -t nfs [虚拟机IP地址]:&#x2F;share   经过以上步骤后，虚拟机上的&#x2F;share目录就会被共享到开发板上，开发板可以通过&#x2F;share目录访问虚拟机上的文件。   交叉编译工具链配置：                                              \n由于我的物理机CPU为Apple M1 Pro，属于ARM64架构，使用命令lscpu  | grep “Architecture”查看架构如下图所示，与开发板架构一样，所以我无需配置交叉编译，直接使用gcc编译即可  \n\n\n配置编译Kernel和Roofs    \n\n下载 Linux 的内核源代码。     \n\n针对所使用的目标平台，对源代码进行配置。   \n ① 查看源码 \n  \n\n ② 编辑make_deb.sh文件\n   \n\n ③执行“make  ARCH&#x3D;arm menuconfig” 配置内核   \n\n交叉编译 Linux 源代码得到内核映像文件 zImage。   \n\n编译配置Qt4.8.7环境  在Ubuntu ARM64系统中安装编译工具和库文件：  sudo apt-get install build-essential  libncurses5-dev libssl-dev bison flex  下载Qt4.8.7源代码，并解压到当前目录：  wget  https://download.qt.io/archive/qt/4.8/4.8.7/qt-everywhere-opensource-src-4.8.7.tar.gz  tar xvfz qt-everywhere-opensource-src-4.8.7.tar.gz  进入Qt4.8.7源代码目录，并执行配置命令：  cd qt-everywhere-opensource-src-4.8.7  .&#x2F;configure -platform  linux-arm-gnueabi-g++  执行.&#x2F;configure命令后，会根据系统环境和你提供的参数，自动生成Qt4.8.7编译所需的Makefile文件。  编译Qt4.8.7：  make  sudo make install  经过以上步骤后，就可以在Ubuntu ARM64系统中编译并安装Qt4.8.7了。\n\n\n\n\n3．Linux设计\nDHT11：  \nA.    电路原理图\n   \n\nB.    驱动控制电平分析  DHT11温湿度传感器上电后，总线空闲状态为高电平，主机把总线拉低等待DHT11响应，主机把总线拉低必须大于18毫秒，保证DHT11能检测到起始信号。DHT11接收到主机的开始信号后，等待主机开始信号结束，然后发送80us低电平响应信号。主机发送开始信号结束后，延时等待20-40us后， 读取DHT11的响应信号，主机发送开始信号后，可以切换到输入模式，或者输出高电平均可，  总线由上拉电阻拉高。  DHT11传感器的DATA引脚检测到外部信号有低电平时，等待外部信号低电平结束，延迟后DHT11的 DATA引脚处于输出状态，输出80微秒的低电平作为应答信号，紧接着输出 80 微秒的高电平通知外设准备接收数据，微处理器的 I&#x2F;O 此时处于输入状态，检测到 I&#x2F;O 有低电平（DHT11 回应信号）后，等待80微秒的高电平后的数据接收。  当主机变为输入模式后，检测到总线为低电平，说明DHT11发送响应信号，DHT11发送响应信号后，再把总线拉高80us，准备发送数据，每一bit数据都以50us低电平时隙开始，高电平的长短定了数据位是“0”还是“1”。 \n\n蜂鸣器：\n  A.    电路原理图\n   \n\n B.    驱动控制电平分析  观察蜂鸣器接口电路图(如上图所示)，其中的蜂鸣器接在 NPN  型三极管的集电极， 而三极管的基极接到了芯片的 GPIO1_19 引脚上，当该引脚输出高电平时，三极管  导通，蜂鸣器响，当输出低电平时，三极管截止，蜂鸣器不响;   C.    驱动程序及其分析  编写驱动程序，在 Ubuntu 的&#x2F;nfs-share  目录下新建一个名为 buzzer 的目录，然后在 该目录下通过 vim 创建一个名为 bz_drv.c  的文件，并输入如下所示的内容，完成后存盘退出   \n#include &lt;linux/module.h&gt;#include &lt;linux/poll.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;volatile unsigned long *(CCM_CCGR1) = NULL; //指向CCM模块中CCGR1寄存器的指针，用于控制模块的时钟。volatile unsigned long *(IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B) = NULL; //指向IOMUXC模块中的寄存器，用于控制UART1的RTS引脚的复用volatile unsigned long *(IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B) = NULL; //指向IOMUXC模块中的寄存器，用于控制UART1的RTS引脚的引脚配置volatile unsigned long *(GPIO1_GDIR) = NULL; //指向GPIO1模块中的寄存器，用于控制GPIO1引脚的方向volatile unsigned long *(GPIO1_DR) = NULL; //指向GPIO1模块中的寄存器，用于控制GPIO1引脚的输出值static struct class *bz_drv_class; //一个指向设备类的指针，用于在内核中注册设备。static int bz_dev_open(struct inode *inode, struct file *file) &#123;   *(CCM_CCGR1) |= 0xC000000; //在 CCM_CCGR1 寄存器中设置控制字段，以启用 UART1 模块   *(IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B) = 0x5; //配置 UART1 的 RTS_B 接口   *(IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B) = 0x1F038;  //配置 UART1 的 RTS_B 接口   *(GPIO1_GDIR) |= 0x80000; //配置 GPIO1 接口的方向，使其成为输出接口   return 0;&#125;static ssize_t bz_dev_write(struct file *filp, const char *buf, size_t count, loff_t * f_pos)&#123;   int val = 1; //声明参数val，并赋值1   unsigned long n;   n = copy_from_user(&amp;val, buf, count); //从用户空间获取val参数的值   if(val==0)//打开蜂鸣器   *(GPIO1_DR) |= (1&lt;&lt;19);    else//关闭蜂鸣器   *(GPIO1_DR) &amp;= ~(1&lt;&lt;19);    return 0;&#125;static struct file_operations bz_dev_fops = &#123;   .owner = THIS_MODULE, //表示模块的所有权，即指向当前模块的指针   .open = bz_dev_open, //函数指针，用于打开设备文件   .write = bz_dev_write, //函数指针，用于向设备文件写入数据&#125;;int major;static int bz_dev_init(void) &#123;   major = register_chrdev(0, &quot;buzzer&quot;, &amp;bz_dev_fops); //注册一个字符设备，并获取主设备号   bz_drv_class = class_create(THIS_MODULE, &quot;buzzer&quot;); //创建一个设备类   device_create(bz_drv_class, NULL, MKDEV(major, 0), NULL, &quot;buzzer&quot;); //在该设备类下创建一个设备   CCM_CCGR1 = (volatile unsigned long *)ioremap(0x20C406C, 4); //将物理地址映射到内核虚拟地址，以便能够访问寄存器   IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B = (volatile unsigned long *)ioremap(0x20E0090, 4); //将物理地址映射到内核虚拟地址，以便能够访问寄存器   IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B = (volatile unsigned long *)ioremap(0x20E031C, 4); //将物理地址映射到内核虚拟地址，以便能够访问寄存器   GPIO1_GDIR = (volatile unsigned long *)ioremap(0x0209C004, 4); //将物理地址映射到内核虚拟地址，以便能够访问寄存器   GPIO1_DR = (volatile unsigned long *)ioremap(0x0209C000, 4); //将物理地址映射到内核虚拟地址，以便能够访问寄存器   return 0;&#125;static void bz_dev_exit(void) &#123;   device_destroy(bz_drv_class, MKDEV(major, 0)); //销毁设备   class_destroy(bz_drv_class); //销毁设备类   unregister_chrdev(major, &quot;buzzer&quot;); //注销字符设备，卸载设备驱动程序&#125; module_init(bz_dev_init); //定义了模块的初始化函数，在模块加载时被调用module_exit(bz_dev_exit); //定义了模块的清除函数，在模块卸载时被调用MODULE_LICENSE(&quot;GPL&quot;); //定义了模块的许可证类型，通常是GPL（GNU General Public License）MODULE_INFO(intree,&quot;Y&quot;); //定义了模块的一些信息，并将值设为“Y”，表示模块包含在内核树中。\n\n\n网络更新程序：服务端使用Java部署在服务器上，用来处理客户端的HTTP Get请求，服务端代码及注释如下\n import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpServer;import java.io.IOException;import java.io.OutputStream;import java.net.*;import java.time.ZoneId;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        // 创建一个HttpServer对象，并设置它监听的端口号        HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0);        // 为服务端程序添加一个处理器，用于处理客户端发来的请求        server.createContext(&quot;/time&quot;, (HttpExchange exchange) -&gt; &#123;            // 获取当前时间            ZonedDateTime now = ZonedDateTime.now();            // 转化为东八区时间            ZonedDateTime chinaTime = now.withZoneSameInstant(ZoneId.of(&quot;Asia/Shanghai&quot;));            // 将时间格式化为yyyy-MM-dd HH:mm:ss            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);            // 将时间格式化为字符串            String formattedDateTime = chinaTime.format(formatter);            // 调试输出            System.out.println(formattedDateTime);            // 设置响应的内容类型为文本            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);            // 将时间字符串写入响应体            exchange.sendResponseHeaders(200, formattedDateTime.length());            OutputStream os = exchange.getResponseBody();            os.write(formattedDateTime.getBytes());            os.close();        &#125;);        // 启动服务端程序，开始处理客户端请求        server.start();    &#125;&#125;\n\n\n\n2客户端直接调用Qt自带类库发起Get请求，并获取响应体内容（即格式化后的日期和时间），代码如下所示\nvoid MainWindow::on_syncButton_clicked()//网络校准按钮点击时发送HTTP GET请求，请求地址为http://localhost:8000/time(localhost为本机地址，也可以指定服务器域名)，响应体为格式化后的yyyy-MM-dd&#123;    // 创建一个QNetworkAccessManager对象，用于发送网络请求     QNetworkAccessManager manager;     // 发送一个GET请求到http://localhost:8000/time     QNetworkReply* reply = manager.get(QNetworkRequest(QUrl(&quot;http://localhost:8000/time&quot;)));     // 等待响应完成     QEventLoop loop;     QObject::connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));     loop.exec();     // 获取响应体的内容     QByteArray responseData = reply-&gt;readAll();     // 将响应体的内容转换为字符串     QString responseString = QString::fromUtf8(responseData);     QDateTime networkTime = QDateTime::fromString(responseString,&quot;yyyy-MM-dd hh:mm:ss&quot;);     setTime(networkTime.time().hour(),networkTime.time().minute(),networkTime.time().second(),networkTime.date().year(),networkTime.date().month(),networkTime.date().day());&#125;\n\n4．Qt设计\n日历实现   \n\n从控件库中拖动一个Calendar Widget和一个Label到mainwindow   \n\n对日历控件做如下设置 \nui-&gt;calendarWidget-&gt;setVerticalHeaderFormat(QCalendarWidget::NoVerticalHeader);//去除年和月标题ui-&gt;calendarWidget-&gt;setGridVisible(true);//网格模式ui-&gt;calendarWidget-&gt;setSelectionMode(QCalendarWidget::NoSelection);//设置不可修改ui-&gt;calendarWidget-&gt;setNavigationBarVisible(false);//去除导航栏\n\n\n\n创建一个线程，getDate(int,int,int)函数获取当前时间时分秒，run()函数判断当前时间是否是23:59:59，如果是则发送信号使日历+1，如下所示  \n#include &quot;refreshcalendarwidget.h&quot;#include &lt;QTime&gt;refreshCalendarWidget::refreshCalendarWidget()&#123;&#125;void refreshCalendarWidget::getDate(int hh,int mm,int ss)//获取当前时间&#123;    recordHour = hh;    recordMinute = mm;    recordSeconde = ss;&#125;void refreshCalendarWidget::run()&#123;    while(1)//循环判断是否需要对日历进行+1操作    &#123;        if (recordHour == 23 &amp;&amp; recordMinute == 59 &amp;&amp; recordSeconde == 59)            emit sendDate(true);        else            emit sendDate(false);        sleep(1);     &#125;&#125;\n\n\n日历设计界面\n   \n\n时钟实现   创建两个线程，一个线程在程序启动时就开始运行，循环获取系统时间，在LCD Number中显示，另一个线程在用户启动它时用setTime(int,int,int)函数获取设置的时间，然后使用重复获取系统时间的方法来计算时间差，然后调用QDateTime的secsTo()函数判断时间差是否为1s，达到更新时间的目的，关键代码如下所示\n#include &quot;timethread.h&quot;#include &lt;QTime&gt;timeThread::timeThread()&#123;&#125;void timeThread::setTime(int hh,int mm,int ss)//设置自定义的时间&#123;     qtime.setHMS(hh,mm,ss,0);     recordTime = QDateTime::currentDateTime();//获取当前系统时间&#125;void timeThread::run()&#123;    while(1)//循环判断系统时间和手动设置的时间差是否为1秒    &#123;        if (QDateTime::currentDateTime().secsTo(recordTime) != 0)        &#123;            recordTime = QDateTime::currentDateTime();//更新记录的时间            qtime = qtime.addSecs(1);//手动设置的时间+1秒        &#125;        emit refreshTime(qtime.toString(&quot;hh:mm:ss&quot;));//发送时间到主线程        usleep(100);     &#125;&#125;\n\n\n\n时钟设计界面    \n\n时钟显示代码\nvoid MainWindow::DisplayTime(QString time)//程序打开时默认显示系统时间&#123;    ui-&gt;lcdNumber-&gt;display(time);&#125;void MainWindow::updateTime(QString time)//手动设置时间后显示时间&#123;    if (isSet)//如果是手动设置的时间则将时间传给myNow        myNow = time;    ui-&gt;lcdNumber-&gt;display(time);&#125;\n\n\n\n温湿度实现  新建一个线程，run()函数里面循环读入&#x2F;dev&#x2F;dht11文件的数据，并从数据中取出温湿度并发送到主线程，关键代码如下所示\n#include &quot;dhtthread.h&quot;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;dhtThread::dhtThread()&#123;&#125;void dhtThread::run()//打开/dev/dht11并循环读取温湿度数据&#123;    char dht[16];    int dhtfd = open(&quot;/dev/dht11&quot;,O_RDONLY);    while(1)    &#123;        read(dhtfd,dht,16);        emit sendDHT(QString::number(dht[2]),QString::number(dht[0]));        sleep(1);     &#125;&#125;\n\n\n\n温湿度设计界面 \n \n\n温湿度显示代码\n void MainWindow::displayDHT(QString temperature, QString humidity)//显示温湿度&#123;    ui-&gt;temperatureLabel-&gt;setText(temperature);    ui-&gt;humidityLabel-&gt;setText(humidity);&#125;\n\n\n\n闹铃实现   1创建一个窗体，窗体内放入三个Spin Box，分别获取时分秒   2创建一个线程，使用setAlarm(int,int,int)函数获取1中设置的值，使用getTime(int,int,int)函数获取当前系统时间，run()函数循环判断两者是否相等，相等则发送信号，蜂鸣器响起函数alarmRing(bool)被执行，从而实现闹钟功能，关键代码如下所示\n#include &quot;alarmthread.h&quot;#include &lt;QTime&gt;alarmThread::alarmThread()&#123;&#125;void alarmThread::setAlarm(int hh,int mm,int ss)//设置闹钟时间&#123;     alarmTime.setHMS(hh,mm,ss,0);&#125;void alarmThread::getTime(int hh,int mm,int ss)//获取当前时间&#123;     nowTime.setHMS(hh,mm,ss,0);&#125;void alarmThread::run()&#123;    while(1)//循环判断是否响起闹钟    &#123;        if (alarmTime.hour() == nowTime.hour() &amp;&amp; alarmTime.minute() == nowTime.minute() &amp;&amp; alarmTime.second() == nowTime.second())        &#123;            emit alarmRing(true);        &#125;        else            emit alarmRing(false);        msleep(100);     &#125;&#125;\n\nvoid MainWindow::alarmRing(bool ring)//闹钟&#123;   if (ring)//闹钟响起   &#123;       ringDialog-&gt;setModal(true);       ringDialog-&gt;show();       //打开蜂鸣器       Buzzerfd = open(&quot;/dev/buzzer&quot;, O_RDWR);       val = 0;       write(Buzzerfd, &amp;val, 1);   &#125;   if (isSet == true)        *time = QTime::fromString(myNow,&quot;hh:mm:ss&quot;);   else       time-&gt;setHMS(QDateTime::currentDateTime().time().hour(),QDateTime::currentDateTime().time().minute(),QDateTime::currentDateTime().time().second(),0);   alarmthread-&gt;getTime(time-&gt;hour(),time-&gt;minute(),time-&gt;second());&#125;\n\n\n闹铃设计界面 \n\n\n闹铃控制代码  在闹钟窗体放置一个Check Box，发送信号时带上其值，主线程判断是否开启闹钟，关键代码如下\nvoid MainWindow::getAlarm(int hh, int mm,int ss,bool isOn)//设置闹钟&#123;    if (isOn)//闹钟是否启用    &#123;        alarmthread-&gt;setAlarm(hh,mm,ss);        alarmthread-&gt;start();    &#125;&#125;\n\n\n\n日历及时间设置实现   1新建一个窗体，放入3个Spin Box，1个Calendar Widget，分别设置时分秒和日期，然后发送信号到主线程的槽函数setTime(int,int,int,int,int,int)，槽函数启动手动设置时间的线程，关键代码如下所示\nvoid MainWindow::setTime(int hh,int mm, int ss,int yyyy,int MM,int dd)//设置LCD显示的时间为手动设置的时间&#123;    QString str = QString(&quot;%1-%2-%3&quot;).arg(yyyy).arg(MM).arg(dd);    QDate date = QDate::fromString(str,&quot;yyyy-M-d&quot;);    TimeshowThread-&gt;terminate();//将默认显示系统时间的线程关闭    TimeThread-&gt;setTime(hh,mm,ss);    TimeThread-&gt;start();    isSet = true;//将标志设置为真，表示当前LCD显示的时间已经修改为手动设置的时间    ui-&gt;calendarWidget-&gt;setSelectedDate(date);&#125;\n\n\n\n日历及时间设置设计界面\n\n\n5．实际运行效果\n\n6．小结电子台历在嵌入式开发板上的实现是一个很有趣的项目，通过它可以学习到很多有关嵌入式开发的知识。在实现过程中，需要熟悉嵌入式开发板的使用，并对相关的硬件设备有一定的了解。需要编写驱动和代码来实现各种功能，例如网络对时、手动设置时间、设置蜂鸣器闹钟和使用 dht11 温湿度传感器实时显示温湿度，这些都是很实用的功能，也能够增加用户体验。  总的来说，这是一个非常有趣和实用的项目，对于学习嵌入式开发有很大的帮助。在实现过程中，需要不断学习和实践，才能够掌握嵌入式开发的相关技能。  \n7．源码GitHub\n","categories":["嵌入式"],"tags":["嵌入式","Qt"]},{"title":"SwiftUI在macOS中监听键盘事件，在TextEditor中实现Enter提交，Enter+Option换行","url":"/SwiftUI-keyboard-listen.html","content":"SwiftUI监听键盘事件SwiftUI中的TextEditor没有类似于TextField的onCommit()或onSubmit()方法，所以无法直接使用Enter键做出此动作。\n下面是一个变通方法，使用NSEvent监听实现Enter提交，Enter+Option换行\nimport SwiftUIstruct TestView: View &#123;  @State private var text = &quot;&quot;  var body: some View &#123;    TextEditor(text: $text)          /*           此处的onChange()是确保按下Enter后能清空TextEditor           SwiftUI有Bug，text = &quot;&quot;并不能完全清空TextEditor，它可能存在换行行为           异步操作模拟按下&quot;delete键&quot;，保证TextEditor完全清空          */          .onChange(of: message.messages.count, perform: &#123; _ in            text = &quot;&quot;            DispatchQueue.main.asyncAfter(deadline: .now() + 0.001) &#123;                NSApplication.shared.sendAction(#selector(NSText.deleteBackward(_:)), to: nil, from: nil)            &#125;          &#125;)          .font(.title2)          .padding(5)          .focused($isFocused)          .frame(minHeight: 15, maxHeight: 180)          .fixedSize(horizontal: false, vertical: true)//使其支持动态调整高度          .scrollContentBackground(.hidden)//去除白色的背景，使其透明          .overlay(              RoundedRectangle(cornerRadius: 15)                  .stroke(isFocused == true ? Color.blue : Color.secondary, lineWidth: isFocused == true ? 2 : 0.3)          )//圆角遮罩        /*         实现Enter提交，Enter+Option换行         注意不能将下面的代码放到NavigationStack里面，否则会提交两次         也就是说&quot;Enter提交&quot;会重复两次,这是不符合预期的        */          .onAppear &#123;            NSEvent.addLocalMonitorForEvents(matching: [.keyDown]) &#123; nsevent in                if nsevent.keyCode == 36 &amp;&amp; !nsevent.modifierFlags.contains(.option) &#123;                    if text.last != nil &#123;                        if !text.isEmpty, !text.allSatisfy(&#123; $0.isNewline &#125;) &#123;                            print(&quot;Enter提交&quot;)                        &#125;                    &#125;                &#125;                return nsevent            &#125;          &#125;  &#125;&#125;\n\n","categories":["SwiftUI"],"tags":["SwiftUI"]},{"title":"OpenWrt 编译","url":"/OpenWrt-Compilation.html","content":"一、准备编译环境\n一个Linux发行版，这里以Ubuntu 24.04.3 LTS为例\n\n安装工具链，详情参考OpenWrt官网\nsudo apt updatesudo apt install build-essential clang flex bison g++ gawk \\gcc-multilib g++-multilib gettext git libncurses5-dev libssl-dev \\python3-setuptools rsync swig unzip zlib1g-dev file wget\n\n二、下载源码并配置\n\n使用普通用户完成下面所有操作，不要使用root\n下面的操作不涉及第三方feeds的添加，这些工具应该在安装完OpenWrt系统后手动安装，不应该编译到固件里面，以免造成编译错误或者固件不稳定\n\n\n\n下载源码\n# 下载源码（-b 指定分支/标签、 --single-branch 仅下载单个分支/标签、 --depth=1 只下载最新的一次提交 ）git clone -b v24.10.5 --single-branch --depth=1 https://github.com/openwrt/openwrt.git# 进入该目录cd openwrt\n\n修改默认时区和网络\n# 编辑配置文件vim package/base-files/files/bin/config_generate\n\n\n修改时区\n# 修改时区为 CST-8set system.@system[-1].timezone=&#x27;CST-8&#x27;# 修改地区为 Asia/Shanghaiset system.@system[-1].zonename=&#x27;Asia/Shanghai&#x27;\n\n修改NTP服务器，推荐下面几个服务器，从上至下，依次是\n\n中国科学院国家授时中心\nApple NTP服务器\nNTP授时快速域名服务\n开源NTP服务器\n\nadd_list system.ntp.server=&#x27;ntp.ntsc.ac.cn&#x27;add_list system.ntp.server=&#x27;time.apple.com&#x27;add_list system.ntp.server=&#x27;cn.ntp.org.cn&#x27;add_list system.ntp.server=&#x27;cn.pool.ntp.org&#x27;\n\n修改IP、网关和DNS\nlan) ipad=$&#123;ipaddr:-&quot;192.168.1.1&quot;&#125; ;;\n\n\n在uci -q batch &lt;&lt;-EOF部分添加下面的内容\n\nset network.$1.gateway=&#x27;192.168.1.1&#x27;set network.$1.dns=&#x27;114.114.114.114 8.8.8.8&#x27;\n\n\n更新并安装插件\ncd ~/openwrt./scripts/feeds clean./scripts/feeds update -a./scripts/feeds install -a\n\n配置\n首先替换.config为官方版本，这里以24.10.5版本，x86&#x2F;64架构为例\ncd ~/openwrtwget https://downloads.openwrt.org/releases/24.10.5/targets/x86/64/config.buildinform -rf .configmv config.buildinfo .config\n\n接着进入配置菜单\nmake menuconfig\n\n\n该界面有如下操作\n\n↑ ↓ 键：上下切换\nPgUp PgDn 键：上下翻页\nEnter 回车键：\n进入子菜单\n选择&#x2F;确认\n\n\nY 键：选中，在 &lt; &gt; 上进行操作，操作后变为 &lt;*&gt;\nN 键：取消选中，在 &lt;*&gt; 上进行操作，操作后变为 &lt; &gt;\nEsc 键：连击两下，返回上层菜单，如果在主菜单则为退出配置\n/键：调出搜索功能\n\n\n建议按照下面的清单配置\n- Target System -&gt; x86- Subtarget -&gt; x86_64- Target Profile -&gt; Generic x86/64- Target Images  - (0) Seconds to wait before booting the default entry // 尽可能快的重启OpenWrt  - (2048) Root filesystem partition size (in MB)  // 尽可能多的分配存储空间- Base system  - &lt;*&gt; block-mount  - &lt; &gt; dnsmasq // 不选，使用下面  - &lt;*&gt; dnsmasq-full // dnsmasq完整版本- LuCI  - Collections    - &lt;*&gt; luci    - &lt;*&gt; luci-ssl  - Modules    - Translations      - &lt;*&gt; Simplified Chinese (zh_Hans)    - &lt;*&gt; luci-compat  - Applications    - 这里不动，安装好OpenWrt系统后手动安装最新版本即可- Network  - File Transfer    - &lt;*&gt; curl    - &lt;*&gt; wget-ssl\n\n注意，如果配置错误，可以执行下面的命令重新配置\nrm -rf ./tmp &amp;&amp; rm -rf .config\n\n三、编译固件\n预下载\n会先下载大部分编译所需文件，后面编译阶段还会下载\nmake download -j8 V=s\n\n编译\n\n全核编译\nmake V=s -j$(nproc)\n\n单线程编译\n\n如果全核编译报错，需要使用单线程编译，排查错误\n\nmake V=s -j1\n\n编译过程非常漫长，以Intel Core i5-10400为例，需要2个小时\n\n如果实在无法找出错误，建议执行下面的命令后从二、下载源码并配置重新开始\n\nrm -rf ~/openwrt\n\n四、获取结果（以x86&#x2F;64为例）cd ~/openwrt/bin/targets/x86/64/ls -all\n\n五、安装系统\n以下操作在路由器的OpenWrt系统中进行\n\n\n先确定系统盘\ndf -h\n\ndd写盘重装\n\n假设镜像在当前目录中，系统盘是&#x2F;dev&#x2F;sda\n\ngzip -dc ./openwrt-24.10.5-x86-64-generic-squashfs-combined-efi.img.gz | dd of=/dev/sda bs=4M\n\n等待几分钟后，显示\n0+94391 records in0+94391 records out\n\n即为写盘成功\n\n重启进入新的OpenWrt系统\n\n这里执行重启命令可能不起作用，可以直接拔掉电源手动重启\n\nreboot\n\n","categories":["Linux"],"tags":["Linux","OpenWrt"]},{"title":"在 M1 Mac 上切换 x86 和 ARM Homebrew","url":"/Switch-x86-and-ARM-Homebrew-on-M1-Mac.html","content":"安装Homebrew1. 安装ARM版/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n\n将ARM版Homebrew设置为默认\n(echo; echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27;) &gt;&gt; /Users/$USER/.zprofileeval &quot;$(/opt/homebrew/bin/brew)&quot;\n\n2. 安装x86版softwareupdate --install-rosettaarch -x86_64 zsh/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n\n设置别名，使其易于切换以zsh为例，bash同理\n(echo; echo &quot;alias armbrew=&#x27;eval \\&quot;\\$(/opt/homebrew/bin/brew shellenv)\\&quot;&#x27;&quot;) &gt;&gt; /Users/$USER/.zshrc(echo; echo &quot;alias x86brew=&#x27;eval \\&quot;\\$(/usr/local/homebrew/bin/brew shellenv)\\&quot;&#x27;&quot;) &gt;&gt; /Users/$USER/.zshrcsource .zshrc\n\narmbrew和x86brew为别名，可根据需求自行设置\n如何切换\n切换到ARM版，默认打开Terminal就是ARM版，可以强制切换\narmbrew\n\n切换到x86版\nx86brew\n\n检查当前Homebrew版本\nwhich brew\n\n\n\n\n路径\n版本\n\n\n\n&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;brew\nARM版\n\n\n&#x2F;usr&#x2F;local&#x2F;homebrew&#x2F;bin&#x2F;brew\nx86版\n\n\n","categories":["homebrew"],"tags":["homebrew"]},{"title":"Hello World","url":"/hello-world.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["博客搭建"],"tags":["博客"]},{"title":"iPhone进入DFU模式刷机","url":"/iPhone-DFU.html","content":"DFU是什么？DFU全称Development Firmware Upgrade，iPhone固件强制升降级模式\niPhone有两种特殊的模式：\n\n恢复模式，屏幕上显示iTunes标志和USB数据线\nDFU模式，也叫强制恢复模式，此模式下iPhone屏幕没有任何显示，是黑屏状态\n\n什么时候进入DFU模式？\n出现白苹果、无限开机等\n需要深度清洁刷机\n\n进入DFU模式\n将iPhone开机并用数据线连接到Mac\n按一下音量+\n按一下音量-\n按住电源键直至手机黑屏关机\n此时不要松开电源键，按住音量-\n进入DFU模式\n\n刷机\n在Mac的“访达”中找到iPhone\n按住⌥option\n鼠标点击“恢复”，选择下载好的固件\n开始刷机\n\n","categories":["iPhone"],"tags":["iPhone","DFU"]}]